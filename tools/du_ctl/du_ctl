#!/usr/bin/env python
# Copyright (c) 2014 Platform9 Systems Inc.
# All Rights Reserved.

"""
Control script for deployment unit related operations
Usage:
#./du_ctl [options]
"""

import argparse
import json
import logging
import os
import re
import requests
import sys
import time

logging.basicConfig(level=logging.DEBUG,
                    format='%(message)s')
log = logging.getLogger('du-ctl')

_bbmaster_endpoint = 'http://localhost:8082/v1/hosts'
_resmgr_endpoint = 'http://localhost:8083/v1'
_keystone_endpoint = 'http://localhost:5000/v2.0/tokens'

_parser = argparse.ArgumentParser()

def login(username, password, tenant):
    """
    Login using username, password, tenant
    :param username: user name
    :param password: password for user
    :param tenant: tenant to login
    :return: Keystone login response json
    """
    """
    Login using username, password, tenant
    """
    data = {
        "auth": {
            "tenantName": tenant,
            "passwordCredentials": {
            "username": username,
            "password": password
            }
        }
    }
    r = requests.post(_keystone_endpoint,
                      json.dumps(data),
                      verify=False,
                      headers={'Content-Type': 'application/json'})
    r.raise_for_status()
    return r.json()

def _get_login_token(args):
    user, password = get_user_pass(args)
    login_resp = login(user, password, 'service')
    return login_resp['access']['token']['id']

def _build_role_parser(subparsers):
    """
    Build subparser for resource manager's roles related operations
    :param subparsers: Subparsers object which is used to build the role
    subparser
    """
    role_parser = subparsers.add_parser('hostrole',
                                        help='Host role related commands')
    role_sub_parser = role_parser.add_subparsers(help='Host role sub-commands',
                                                 dest='role_subparser')

    role_apply_parser = role_sub_parser.add_parser('apply',
                                                   help='Apply a role to a host')
    role_apply_parser.add_argument('--host_id',
                                   action='store',
                                   dest='host_id',
                                   required=True,
                                   help='Host ID of the host to which the role is going to be applied')
    role_apply_parser.add_argument('--role',
                                   action='store',
                                   dest='role',
                                   required=True,
                                   help='Name of the role that is being applied')
    role_apply_parser.add_argument('--user_token_file',
                                   action='store',
                                   dest='user_token_file',
                                   required=True,
                                   help='File containing user token for this operation')

def _build_hostagent_parser(subparsers):
    """
    Build subparser for host agent related operations
    :param subparsers: Subparsers object which is used to build the role
    subparser
    """
    agent_parser = subparsers.add_parser('hostagent',
                                         help='Host agent commands')

    agent_sub_parser = agent_parser.add_subparsers(help='Host agent sub-commands',
                                                   dest='agent_subparser')

    # Parser for restart
    agent_restart_parser = agent_sub_parser.add_parser('restart',
                                                      help='Restart the host agent')
    agent_restart_parser.add_argument('--host_id',
                    action='store',
                    dest='host_id',
                    required=True,
                    help='Host ID of the host to restart')

    # Parser for update
    agent_update_parser = agent_sub_parser.add_parser('update',
                                                      help='Update the host agent')
    agent_update_parser.add_argument('--host_id',
                    action='store',
                    dest='host_id',
                    required=True,
                    help='Host ID of the host to which the agent update has to be applied')
    agent_update_parser.add_argument("--agent_version",
                      action='store',
                      dest='agent_version',
                      required=True,
                      help='Version of the hostagent that is being updated to.')
    agent_update_parser.add_argument("--agent_name",
                      action='store',
                      dest='agent_name',
                      default='pf9-hostagent',
                      help='Name of the hostagent package. Defaults to pf9-hostagent')
    agent_update_parser.add_argument("--agent_url",
                      action='store',
                      dest='agent_url',
                      required=True,
                      help='URL from where this agent package can be downloaded from')

    # Parser for list
    agent_list_parser = agent_sub_parser.add_parser('list',
                                                    help='List the hosts and its details')
    agent_list_parser.add_argument('--host',
                      action='store',
                      dest='host',
                      help='ID of the specific host to be queried. If not specified, '
                           'all hosts are queried')

def _add_credential_arguments(parser):
    parser.add_argument("--user",
		        action='store',
		        dest='user',
		        help='User account to use. Optional if OS_USERNAME is set.')
    parser.add_argument("--password",
                        action='store',
                        dest='password',
                        help='User account password. Optional if OS_PASSWORD is set.')

def _build_host_parser(subparsers):
    """
    Build subparser for host related operations
    :param subparsers: Subparsers object which is used to build the host
    subparser
    """
    host_parser = subparsers.add_parser('host',
                                        help='Host commands')
    host_sub_parser = host_parser.add_subparsers(help='Host sub-commands',
                                                 dest='host_subparser')

    host_list_parser = host_sub_parser.add_parser('list',
                                                  help='List hosts information')
    _add_credential_arguments(host_list_parser)

    host_role_reset_parser = host_sub_parser.add_parser('role-reset',
                                                        help='Reset host roles')
    host_role_reset_parser.add_argument("--host_id",
                                        action='store',
                                        dest='host_id',
                                        required=True,
                                        help='Host ID of host where its roles should be cleared')
    _add_credential_arguments(host_role_reset_parser)

    host_support_parser = host_sub_parser.add_parser('support',
                                                     help='Get support bundle from hosts')
    host_support_sub_parser = host_support_parser.add_subparsers(help='Host support sub-commands',
                                                                 dest='host_support_subparser')
    host_support_bundle_parser = host_support_sub_parser.add_parser('bundle',
                                                                    help='Get support bundle')
    host_support_bundle_parser.add_argument("--host_id",
                                            required=True,
                                            help='ID of host to get support bundle from. ')
    _add_credential_arguments(host_support_bundle_parser)

    host_support_command_parser = host_support_sub_parser.add_parser('command',
                                                                     help='Run a command on a host')
    host_support_command_parser.add_argument("--host_id",
                                            required=True,
                                            help='ID of host to get support bundle from. ')
    host_support_command_parser.add_argument("--command",
                                            required=True,
                                            help='The command to run.')
    _add_credential_arguments(host_support_command_parser)

def _build_parsers():
    """
    Build the command line parser hierarchy based on the control script actions
    """
    subparsers = _parser.add_subparsers(help='sub-commands',
                                        dest='subparser')
    _build_role_parser(subparsers)
    _build_hostagent_parser(subparsers)
    _build_host_parser(subparsers)

def _process_cmd(args):
    """
    Does the work of the command.
    :param args: command line args parsed from argparse
    """
    if args.subparser == 'hostagent':
        if args.agent_subparser == 'update':
            if not (args.host_id and args.agent_version and args.agent_url):
                # Should never hit this because argparse's parsing should take
                # care of this, but keeping it here as a safety net.
                log.error('Missing mandatory arguments for host agent update')
                _parser.print_help()
                sys.exit(1)
            else:
                # Agent update
                do_agent_update(args)
                return
        elif args.agent_subparser == 'list':
            do_agent_list(args)
            return
        elif args.agent_subparser == 'restart':
            if not args.host_id:
                # Should never hit this because argparse's parsing should take
                # care of this, but keeping it here as a safety net.
                log.error('Missing mandatory arguments for host agent restart')
                _parser.print_help()
                sys.exit(1)
            do_agent_restart(args)
            return

    if args.subparser == 'hostrole':
        if args.role_subparser == 'apply':
            do_set_host_role(args)
            return

    if args.subparser == 'host':
        if args.host_subparser == 'list':
            do_host_list(args)
            return
        elif args.host_subparser == 'role-reset':
            do_host_role_reset(args)
            return
        elif args.host_subparser == 'support':
            if args.host_support_subparser == 'bundle':
                do_support_bundle(args)
                return
            elif args.host_support_subparser == 'command':
                do_support_command(args)
                return

    # Did not match any known command. Should not hit this because argparse
    # should do everything for us.
    _parser.print_help()


def get_user_pass(args):
    """
    Get username, password from command line args, if provided. Otherwise,
    use the environment variables to pick up these values. Else error out.
    :param args: Command line args
    :return: Tuple of username and password
    """
    if not args.user:
        args.user = os.getenv('OS_USERNAME')
    if not args.password:
        args.password = os.getenv('OS_PASSWORD')

    if not args.password or not args.user:
        log.info('Username/password is missing')
        _parser.print_help()
        sys.exit(1)

    return args.user, args.password

def do_host_list(args):
    """
    Retrieve information for all hosts
    :param args: Command line args
    """
    headers = {'X-Auth-Token': _get_login_token(args)}
    resp = _do_get('%s/hosts' % _resmgr_endpoint, headers=headers)
    log.info('%s', json.dumps(resp, indent=3))

def do_host_role_reset(args):
    """
    Remove all roles associated with a host
    :param args: Command line args
    """
    headers = {'Content-type': 'json',
               'X-Auth-Token': _get_login_token(args)}
    resp = requests.delete('%s/hosts/%s' % (_resmgr_endpoint, args.host_id),
                           headers=headers)
    resp.raise_for_status()
    log.info('All roles reset for host %s. It will take a few minutes for'
             ' the role reset to be synchronized across all services.', args.host_id)

def _get_bundles(bundle_dir):
    """
    Return a set of the paths of the bundles in bundle_dir.
    A bundle name should be of the form:
        <hostname>-<time>.tgz
    where time is generated by datetime.strftime("%Y-%m-%d-%H-%M-%S").
    We will NOT consider hostnames when looking for bundles.
    Logs a warning if bundle_dir is not a directory.
    """
    bundle_pattern = re.compile('.*-(\d{4})' + '(-\d{2})' * 5 + '.tgz$')
    bundles = set()
    try:
        bundle_dir_list = os.listdir(bundle_dir)
    except OSError:
        log.exception("Could not access bundle dir: %s" % bundle_dir)
        return bundles
    for bundle_name in bundle_dir_list:
        bundle = os.path.join(bundle_dir, bundle_name)
        if bundle_pattern.match(bundle):
            bundles.add(bundle)
    return bundles

def do_support_bundle(args):
    headers = {'X-Auth-Token': _get_login_token(args)}
    support_dir = os.path.join('/opt', 'pf9', 'support', args.host_id)

    bundles_before = _get_bundles(support_dir)

    resp = requests.post('%s/hosts/%s/support/bundle' % (_resmgr_endpoint, args.host_id),
                         headers=headers)
    resp.raise_for_status()

    # Number of attempts to check for creation of the support bundle
    attempts = 60
    interval = 5
    for _ in xrange(attempts):
        time.sleep(interval)
        bundles_after = _get_bundles(support_dir)
        new_bundles = bundles_after - bundles_before
        if len(new_bundles):
            if len(new_bundles) != 1:
                log.warn('Multiple bundles written!')
            log.info('Wrote new bundle: %s' % new_bundles.pop())
            return
        log.info("Waiting for support bundle...")

    log.error("Failed while waiting for support bundle")
    sys.exit(1)

def do_support_command(args):
    headers = {'X-Auth-Token' : _get_login_token(args),
               'Content-Type' : 'application/json'}
    body = {'command' : args.command}
    resp = requests.post('%s/hosts/%s/support/command/' % (_resmgr_endpoint, args.host_id),
                         headers=headers, data=json.dumps(body))
    resp.raise_for_status()

def _do_get(url, headers={}):
    """
    Execute the GET http call
    :param str url: URL to run the GET call on
    :return: JSON response
    :rtype: JSON encoded dict
    """
    headers['Content-type'] = 'json'
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    return resp.json()

def _do_method(url, method, body, headers):
    """
    Execute a request that contains a body
    :param str url: URL to send the request
    :param dict body: Request body
    :return: JSON response
    :rtype: JSON encoded dict
    """
    headers['Content-type'] = 'json'
    resp = method(url, data=json.dumps(body), headers=headers)
    resp.raise_for_status()
    return resp.json()

def _do_put(url, body=None, headers={}):
    return _do_method(url, requests.put, body, headers)

def _do_post(url, body=None, headers={}):
    return _do_method(url, requests.post, body, headers)

def _update_and_poll(options, cur_host_agent_version):
    """
    Trigger a host agent update and poll for its status change
    :param ParserOption options: command line options
    :param str cur_host_agent_version: Version of the current host agent
    on the host
    """
    host_endpoint = ''.join([_bbmaster_endpoint, '/', options.host_id])
    put_req = ''.join([host_endpoint, '/hostagent'])
    agent_data = {
        'version': options.agent_version,
        'name': options.agent_name,
        'url': options.agent_url
    }
    try:
        _do_put(put_req, agent_data)

        time_left = 10 * 60    # 10 mins
        poll_interval = 20    # 20 secs
        updating = False
        while (time_left):
            host_details = _do_get(host_endpoint)
            host_agent_status = host_details['host_agent']['status']
            host_agent_version = host_details['host_agent']['version']
            if host_agent_version == options.agent_version:
                log.info('Host agent for host %s is at version %s',
                         options.host_id, options.agent_version)
                return
            if host_agent_status == 'updating':
                updating = True
            else:
                # agent_status is 'ok'
                if host_agent_version == cur_host_agent_version and updating:
                    # The host was updating but has now reverted to ok with the
                    # agent version back to the old version. Implies error
                    log.error('Host agent update failed for host. Agent version '
                              'is %s', host_agent_version)
                    sys.exit(1)

            log.info('Agent update status : %s, agent version: %s',
                     host_agent_status, host_agent_version)

            time.sleep(poll_interval)
            time_left -= poll_interval

    except Exception:
        log.exception('Update host agent request failed')
        sys.exit(1)

def do_agent_list(options):
    """
    List host agent related details
    :param options: args parsed from command line by argparser
    """
    resp = []
    if options.host:
        url = ''.join([_bbmaster_endpoint, '/', options.host])
        query_op = _do_get(url)
        resp.append(query_op)
    else:
        resp = _do_get(_bbmaster_endpoint)

    output = []
    for host in resp:
        temp = {
            'host id': host['host_id'],
            'agent info': host['host_agent']
        }
        output.append(temp)

    log.info('%s', json.dumps(output, indent=3))

def _ensure_host_exists(options):
    resp = _do_get(''.join([_bbmaster_endpoint, '/ids']))
    if options.host_id not in resp:
        log.info('Host ID %s not in list of hosts that backbone is aware of',
             options.host_id)
        raise Exception()

def do_agent_update(options):
    """
    Perform host agent update
    :param ParserOption options: command line options
    """
    try:
        _ensure_host_exists(options)
        # Query host details.
        host_endpoint = ''.join([_bbmaster_endpoint, '/', options.host_id])
        resp = _do_get(host_endpoint)
    except Exception:
        log.exception('Querying host details failed')
        sys.exit(1)

    # If host agent is already in expected version, do nothing
    if resp['host_agent']['version'] == options.agent_version:
        log.info('Host agent on %s already at version %s',
                 options.host_id, options.agent_version)
        return

    # If the host agent is currently updating, quit
    if resp['host_agent']['status'] == 'updating':
        log.info('Host %s is currently updating the host agent. Try again later.',
                 options.host_id)
        return

    # push update
    _update_and_poll(options, resp['host_agent']['version'])

def do_agent_restart(options):
    """
    Perform host agent restart
    :param ParserOption options: command line options
    """
    _ensure_host_exists(options)
    url = ''.join([_bbmaster_endpoint, '/', options.host_id, '/support/command'])
    body = {'command': 'sudo service pf9-hostagent restart'}
    _do_post(url, body)

def do_set_host_role(options):
    """
    Applies the role to a host
    :param options: command line options that are passed in for this command
    """
    def up_to_date():
        """
        Query the backbone API and return a boolean value specifying whether
        the role was successfully updated.
        """
        host_info_endpoint = ''.join([_bbmaster_endpoint, '/', options.host_id])
        host_info = _do_get(host_info_endpoint)
        app_details = host_info['apps']
        app_status = host_info['status']
        log.info('Checking if role %s for host %s is up to date',
                  options.role,
                  options.host_id)
        log.info('apps: %s', app_details)
        log.info('app status: %s', app_status)
        return (all(app in app_details and
                    app_details[app]['version'] == app_version
                    for app, app_version in app_versions.iteritems())
                and app_status == 'ok')

    # Ensure host ID exists
    if options.host_id not in _do_get(''.join([_bbmaster_endpoint, '/ids'])):
        log.error('Host ID %s not in list of hosts that backbone is aware of',
                 options.host_id)
        sys.exit(1)

    # Set up the headers
    with open(options.user_token_file) as token_file:
        auth_token = token_file.read()
    headers = {'X-Auth-Token': auth_token}

    app_ver_endpoint = ''.join([_resmgr_endpoint,
                                '/roles/',
                                options.role,
                                '/apps/versions'])
    app_versions = _do_get(app_ver_endpoint, headers=headers)

    # If the apps for the specified role are already at the expected version, do nothing
    if up_to_date():
        log.info('%s on %s is already up to date',
                 options.role, options.host_id)
        return

    try:
        url = ''.join([_resmgr_endpoint, '/hosts/', options.host_id, '/roles/', options.role])
        log.info('Updating role %s for host %s', options.role, options.host_id)
        _do_put(url, body=None, headers=headers)

        time_left = 10 * 60    # 10 mins
        poll_interval = 20     # 20 secs
        while time_left:
            time.sleep(poll_interval)
            time_left -= poll_interval

            if up_to_date():
                log.info('Role %s for host %s is up to date',
                         options.role, options.host_id)
                return
            log.info('Waiting for host %s to update role %s',
                     options.host_id, options.role)
    except Exception:
        log.exception('Request to update host %s with role %s failed',
                      options.host_id,
                      options.role)
    log.error('Failed while updating host %s with role %s',
              options.host_id,
              options.role)
    sys.exit(1)

def main():
    _build_parsers()
    args = _parser.parse_args()
    _process_cmd(args)

if __name__ == '__main__':
    main()
